% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_pattern.R
\name{tar_pattern}
\alias{tar_pattern}
\alias{map}
\alias{cross}
\alias{head}
\alias{tail}
\alias{sample}
\title{Emulate dynamic branching.}
\usage{
tar_pattern(pattern, ..., seed = 0L)
}
\arguments{
\item{pattern}{Function call with the pattern specification.}

\item{...}{Named vectors to represent upstream targets.
Each name is the name of a whole stem or pattern,
and each vector element is a character with the name of an
upstream bud or branch. Buds are pieces of non-branching targets
("stems") and branches are pieces of patterns. Names must be unique.
If you do not supply character vectors, they will be coerced to
character vectors.}

\item{seed}{Integer of length 1, random number generator seed to
emulate the pattern reproducibly. (The \code{sample()} pattern is random).
In a real pipeline, the seed is automatically generated
from the target name in deterministic fashion.}
}
\value{
A \code{tibble} showing the kinds of dynamic branches that
\code{\link[=tar_target]{tar_target()}} would create in a real pipeline with the given \code{pattern}.
Each row is a dynamic branch, each column is a dependency target,
and each element is the name of an upstream bud or branch that the
downstream branch depends on. Buds are pieces of non-branching targets
("stems") and branches are pieces of patterns.
}
\description{
Emulate the dynamic branching process outside a pipeline.
\code{tar_pattern()} can help you understand which branches
will be created when you set the \code{pattern} argument of \code{\link[=tar_target]{tar_target()}}.
}
\details{
Dynamic branching is a way to programmatically
create multiple new targets based on the values of other targets,
all while the pipeline is running. Use the \code{pattern} argument of
\code{\link[=tar_target]{tar_target()}} to get started. \code{pattern} accepts a function call
composed of target names and any of the following patterns:
\itemize{
\item \code{map()}: create one branch for each corresponding element of
its arguments. \code{map(x, y)} creates one branch for the first
elements of \code{x} and \code{y}, another branch for the second
elements of \code{x} and \code{y}, and so on.
\item \code{cross()}: create one branch for each combination
of elements of the arguments.
\item \code{head()}: restrict branching to the first few elements.
\item \code{tail()}: restrict branching to the last few elements.
\item \code{sample()}: restrict branching to a random subset of elements.
}
}
\examples{
# To use dynamic map for real in a pipeline,
# call map() in a target's pattern.
# The following code goes at the bottom of _targets.R.
tar_pipeline(
  tar_target(x, seq_len(2)),
  tar_target(y, head(letters, 2)),
  tar_target(dynamic, c(x, y), pattern = map(x, y)) # 2 branches
)
# Likewise for more complicated patterns.
tar_pipeline(
  tar_target(x, seq_len(2)),
  tar_target(y, head(letters, 2)),
  tar_target(z, head(LETTERS, 2)),
  tar_target(dynamic, c(x, y, z), pattern = cross(z, map(x, y))) #4 branches
)
# But you can emulate dynamic branching without running a pipeline
# in order to understand the patterns you are creating.
# First, you have to make up some names for pieces of targets
# ("buds" and branches). The following are reasonably realistic branch names
# that `targets` might generate during [tar_make()], but they need not be
# totally realistic for emulation purposes.
x <- c("x_550d7456", "x_a20cadbf", "x_eeb00f1b")
y <- c("x_42f35290", "x_f95ad1c7")
z <- c("x_67188e74", "x_5512ec97")
# Then, call `tar_pattern()` to emulate the pattern.
tar_pattern(
  cross(x, map(y, z)),
  x = x,
  y = y,
  z = z
)
tar_pattern(
  head(cross(x, map(y, z)), n = 2),
  x = x,
  y = y,
  z = z
)
}
