% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_target.R
\name{tar_target}
\alias{tar_target}
\title{Declare a target.}
\usage{
tar_target(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option("tidy_eval", TRUE),
  packages = targets::tar_option("packages", (.packages())),
  library = targets::tar_option("library"),
  format = targets::tar_option("format", "rds"),
  iteration = targets::tar_option("iteration", "vector"),
  error = targets::tar_option("error", "stop"),
  memory = targets::tar_option("memory", "persistent"),
  template = targets::tar_option("template", NULL),
  deployment = targets::tar_option("deployment", "remote"),
  priority = 0,
  resources = targets::tar_option("resources", list()),
  storage = targets::tar_option("storage", "local"),
  retrieval = targets::tar_option("retrieval", storage),
  cue = targets::tar_option("cue", NULL)
)
}
\arguments{
\item{name}{Symbol, name of the target.}

\item{command}{R code to run the target.}

\item{pattern}{Language to define branching for a target.
For example, in a pipeline with numeric vector targets \code{x} and \code{y},
\code{tar_target(z, x + y, pattern = map(x, y))} implicitly defines
branches of \code{z} that each compute \code{x[1] + y[1]}, \code{x[2] + y[2]},
and so on. See the user manual for details.}

\item{tidy_eval}{Logical, whether to enable tidy evaluation
when interpreting \code{expr}. If \code{TRUE}, you can use the
"bang-bang" operator \verb{!!} to programmatically insert
the values of global objects.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_options()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{format}{Optional storage format for the target's return value.
With the exception of \code{format = "file"}, each target
gets a file in \verb{_targets/objects}, and each format is a different
way to save and load this file.
Possible formats:
\itemize{
\item \code{"file"}: A dynamic file. To use this format,
the target needs to manually identify or save some data
and return a character vector of paths
to the data. Those paths must point to files or directories,
and they must not contain characters \code{|} or \code{*}.
Then, \code{targets} automatically checks those files and cues the
appropriate build decisions if those files are out of date.
\item \code{"rds"}: Default, uses \code{saveRDS()} and \code{readRDS()}. Should work for
most objects, but slow.
\item \code{"qs"}: Uses \code{qs::qsave()} and \code{qs::qread()}. Should work for
most objects, much faster than \code{"rds"}.
\item \code{"fst"}: Uses \code{fst::write_fst()} and \code{fst::read_fst()}.
Much faster than \code{"rds"}, but the value must be
a data frame.
\item \code{"fst_dt"}: Same as \code{"fst"}, but the value is a \code{data.table}.
\item \code{"fst_tbl"}: Same as \code{"fst"}, but the value is a \code{tibble}.
\item \code{"keras"}: Uses \code{keras::save_model_hdf5()} and
\code{keras::load_model_hdf5()}. The value must be a Keras model.
}}

\item{iteration}{Character of length 1, name of the iteration mode
of the target. Choices:
\itemize{
\item \code{"vector"}: branching happens with \code{vectors::vec_slice()} and
aggregation happens with \code{vctrs::vec_c()}.
\item \code{"list"}, branching happens with \verb{[[]]} and aggregation happens with
\code{list()}.
\item \code{"group"}: \code{dplyr::group_by()}-like functionality to branch over
subsets of a data frame. The target's return value must be a data
frame with a special \code{tar_group} column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the \code{\link[=tar_group]{tar_group()}} function to see how you can
create the special \code{tar_group} column with \code{dplyr::group_by()}.
}}

\item{error}{Character of length 1, what to do if the target
runs into an error. If \code{"stop"}, the whole pipeline stops
and throws an error. If \code{"continue"}, the error is recorded,
but the pipeline keeps going.}

\item{memory}{Character of length 1, memory strategy.
If \code{"persistent"}, the target stays in memory
until the end of the pipeline.
If \code{"transient"}, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.}

\item{template}{Relevant to \code{\link[=tar_make_clustermq]{tar_make_clustermq()}} only.
Named list of values to fill in the \code{clustermq} template file.
Unsupported for now. May be supported in the future if
\code{clustermq} ever supports heterogeneous workers with varying
resource requirements. In the meantime, use the \code{template}
argument of \code{\link[=tar_make_clustermq]{tar_make_clustermq()}}.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[=tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[=tar_make_future]{tar_make_future()}}. If \code{"remote"},
the target builds on a remote parallel worker. If \code{"local"},
the target builds on the host machine / process managing the pipeline.}

\item{priority}{Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get built earlier.}

\item{resources}{Relevant to \code{\link[=tar_make_future]{tar_make_future()}} only.
A named list of resources passed to \code{future::future()} when
defining a new worker.}

\item{storage}{Character of length 1, only relevant to
\code{\link[=tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[=tar_make_future]{tar_make_future()}}.
If \code{"local"}, the target's return value is sent back to the
host machine and saved locally. If \code{"remote"}, the remote worker
saves the value.}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[=tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[=tar_make_future]{tar_make_future()}}.
If \code{"local"}, the target's dependencies are loaded on the host machine
and sent to the remote worker before the target builds.
If \code{"remote"}, the remote worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}
}
\value{
A target object. Users should not modify these directly,
just feed them to \code{\link[=tar_pipeline]{tar_pipeline()}} in your \verb{_targets.R} file.
}
\description{
A target is a single step of computation in a pipeline.
It runs an R command (\code{expr} argument) and returns a value.
This value gets treated as an R object that can be used
by the commands of targets downstream. Targets that
are already up to date are skipped. See the user manual
for more details.
}
\examples{
# Defining targets does not run them.
data <- tar_target(target_name, get_data(), packages = "tidyverse")
analysis <- tar_target(analysis, analyze(x), pattern = map(x))
# Pipelines accept targets.
pipeline <- tar_pipeline(data, analysis)
# Tidy evaluation
tar_options()
n_rows <- 30L
data <- tar_target(target_name, get_data(!!n_rows))
print(data)
# Disable tidy evaluation:
data <- tar_target(target_name, get_data(!!n_rows), tidy_eval = FALSE)
print(data)
}
