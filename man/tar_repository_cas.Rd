% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_repository_cas.R
\name{tar_repository_cas}
\alias{tar_repository_cas}
\title{Define a custom content-addressable storage (CAS) repository.}
\usage{
tar_repository_cas(upload, download, exists, consistent = FALSE)
}
\arguments{
\item{upload}{A function with arguments \code{path} and \code{key}, in that order.
This function should upload the file or directory at \code{path}
to the CAS system. \code{key} denotes the name of the destination data object
in the CAS system.}

\item{download}{A function with arguments \code{path} and \code{key}, in that order.
This function should download the data object at \code{key} from
the CAS system to the file or directory at \code{path}.
to the CAS system. \code{key} denotes the name of the destination data object
in the CAS system.}

\item{exists}{A function with a single argument \code{key}.
This function should check if there is an object at \code{key} in
the CAS system.'}

\item{consistent}{Logical. Set to \code{TRUE} if the storage platform is
strongly read-after-write consistent. Set to \code{FALSE} if the platform
is not necessarily strongly read-after-write consistent.

A data storage system is said to have strong read-after-write consistency
if a new object is fully available for reading as soon as the write
operation finishes. Many modern cloud services like Amazon S3 and
Google Cloud Storage have strong read-after-write consistency,
meaning that if you upload an object with a PUT request, then a
GET request immediately afterwards will retrieve the precise
version of the object you just uploaded.

Some storage systems do not have strong read-after-write consistency.
One example is network file systems (NFS). On a computing cluster,
if one node creates a file on an NFS, then there is a delay before
other nodes can access the new file. \code{targets} handles this situation
by waiting for the new file to appear with the correct hash
before attempting to use it in downstream computations.
\code{consistent = FALSE} imposes a waiting period in which \code{targets}
repeatedly calls the \code{exists} method until the file becomes available
(at time intervals configurable with \code{\link[=tar_resources_network]{tar_resources_network()}}).
These extra calls to \code{exists} may come with a
little extra latency / computational burden,
but on systems which are not strongly read-after-write consistent,
it is the only way \code{targets} can safely use the current results
for downstream computations.}
}
\description{
Define a custom storage repository that uses
content-addressable storage (CAS).
}
\details{
Repository functions:
In \code{\link[=tar_repository_cas]{tar_repository_cas()}}, functions \code{upload}, \code{download},
and \code{exists} must be perfectly pure
and perfectly self-sufficient.
They must load or namespace all their own packages,
and they must not depend on any custom user-defined
functions or objects in the global environment of your pipeline.
\code{targets} converts each function to and from text,
so it must not rely on any data in the closure.
This disqualifies functions produced by \code{Vectorize()},
for example.

Some functions may need to be adapted and configured based on other
inputs. For example, you may want to define
\verb{upload = \\(path, key) file.move(path, file.path(folder, key))}
but do not want to hard-code a value of \code{folder} when you write the
underlying function. \code{substitute()} can help inject values as needed.
For example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{upload = substitute(
  \\(path, key) file.move(path, file.path(folder, key)),
  list(folder = "my_cas")
)
}\if{html}{\out{</div>}}
}
\seealso{
Other targets: 
\code{\link{tar_cue}()},
\code{\link{tar_format}()},
\code{\link{tar_target}()},
\code{\link{tar_target_raw}()}
}
\concept{targets}
