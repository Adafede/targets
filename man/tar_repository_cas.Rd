% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_repository_cas.R
\name{tar_repository_cas}
\alias{tar_repository_cas}
\title{Define a custom content-addressable storage
(CAS) repository (an experimental feature).}
\usage{
tar_repository_cas(upload, download, exists, consistent = FALSE)
}
\arguments{
\item{upload}{A function with arguments \code{key} and \code{path}, in that order.
This function should upload the file or directory from \code{path}
to the CAS system.
\code{path} is where the file is originally saved to disk outside the CAS
system. It could be a staging area or a custom \code{format = "file"}
location. \code{key} denotes the name of the destination data object
in the CAS system.

\code{upload} must only copy the file to its destination and not
remove the original source path. This is because \code{format = "file"}
targets should remain on disk after the upload phase. For non-\code{"file"}
formats, \code{targets} will remove the temporary staging file
automatically after the upload is finished. If you are working on your
local machine and have need for a CAS system, it is likely that the
CAS object files will exist on a different drive than your local
file environment anyway, which means copying will probably have to
take place regardless.}

\item{download}{A function with arguments \code{key} and \code{path}, in that order.
This function should download the data object at \code{key} from
the CAS system to the file or directory at \code{path}.
\code{key} denotes the name of the data object in the CAS system.
\code{path} is a temporary staging area and not the final destination.}

\item{exists}{A function with a single argument \code{key}.
This function should check if there is an object at \code{key} in
the CAS system.

For efficiency, \code{exists} can maintain an in-memory cache of keys.
New lookups can check the cache and potentially avoid expensive
queries to the CAS system. See the source code of
\code{\link[=tar_repository_cas_local_exists]{tar_repository_cas_local_exists()}}
for an example of how this can work for a local file system CAS.}

\item{consistent}{Logical. Set to \code{TRUE} if the storage platform is
strongly read-after-write consistent. Set to \code{FALSE} if the platform
is not necessarily strongly read-after-write consistent.

A data storage system is said to have strong read-after-write consistency
if a new object is fully available for reading as soon as the write
operation finishes. Many modern cloud services like Amazon S3 and
Google Cloud Storage have strong read-after-write consistency,
meaning that if you upload an object with a PUT request, then a
GET request immediately afterwards will retrieve the precise
version of the object you just uploaded.

Some storage systems do not have strong read-after-write consistency.
One example is network file systems (NFS). On a computing cluster,
if one node creates a file on an NFS, then there is a delay before
other nodes can access the new file. \code{targets} handles this situation
by waiting for the new file to appear with the correct hash
before attempting to use it in downstream computations.
\code{consistent = FALSE} imposes a waiting period in which \code{targets}
repeatedly calls the \code{exists} method until the file becomes available
(at time intervals configurable with \code{\link[=tar_resources_network]{tar_resources_network()}}).
These extra calls to \code{exists} may come with a
little extra latency / computational burden,
but on systems which are not strongly read-after-write consistent,
it is the only way \code{targets} can safely use the current results
for downstream computations.}
}
\description{
Define a custom storage repository that uses
content-addressable storage (CAS).
}
\details{
See the \code{\link[=tar_repository_cas_local]{tar_repository_cas_local()}} function for an example
CAS system based on a local folder on disk.
It uses \code{\link[=tar_repository_cas_local_upload]{tar_repository_cas_local_upload()}},
\code{\link[=tar_repository_cas_local_download]{tar_repository_cas_local_download()}}, and
\code{\link[=tar_repository_cas_local_exists]{tar_repository_cas_local_exists()}} for the respective
\code{upload}, \code{download}, and \code{exists} methods.
See the "Repository functions" section for specific advice on how
to write your own methods.
}
\section{Repository functions}{

In \code{\link[=tar_repository_cas]{tar_repository_cas()}}, functions \code{upload}, \code{download},
and \code{exists} must be perfectly pure
and perfectly self-sufficient.
They must load or namespace all their own packages,
and they must not depend on any custom user-defined
functions or objects in the global environment of your pipeline.
\code{targets} converts each function to and from text,
so it must not rely on any data in the closure.
This disqualifies functions produced by \code{Vectorize()},
for example.

\code{upload} and \code{download} should also handle directory outputs in
some way. Either they should assume \code{path} can be a directory
as well as a file, or \code{upload} should throw an error if \code{path}
is a directory.

Some functions may need to be adapted and configured based on other
inputs. For example, you may want to define
\verb{upload = \\(key, path) file.move(path, file.path(folder, key))}
but do not want to hard-code a value of \code{folder} when you write the
underlying function. \code{substitute()} can help inject values into the
body of a function. For example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{upload <-  \\(key, path) \{\}
body(upload) <- substitute(
  file.move(path, file.path(folder, key)),
  list(folder = "my_cas")
)
print(upload)
}\if{html}{\out{</div>}}

Temporary or sensitive such as authentication credentials
should not be injected
this way into the function body. Instead, pass them as environment
variables using \code{\link[=tar_resources_repository_cas]{tar_resources_repository_cas()}}.
}

\examples{
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  repository <- tar_repository_cas(
    upload = function(key, path) {
      if (dir.exists(path)) {
        stop("This CAS repository does not support directory outputs.")
      }
      if (!file.exists("cas")) {
        dir.create("cas", recursive = TRUE)
      }
      file.copy(path, file.path("cas", key))
    },
    download = function(key, path) {
      file.copy(file.path("cas", key), path)
    },
    exists = function(key) {
      file.exists(file.path("cas", key))
    }
  )
  write_file <- function(object) {
    writeLines(as.character(object), "file.txt")
    "file.txt"
  }
  list(
    tar_target(x, c(2L, 4L), repository = repository),
    tar_target(
      y,
      x,
      pattern = map(x),
      format = "qs",
      repository = repository
    ),
    tar_target(z, write_file(y), format = "file", repository = repository)
  )
})
tar_make(callr_function = NULL)
tar_read(y)
tar_read(z)
list.files("cas")
tar_meta(any_of(c("x", "z")), fields = any_of("data"))
})
}
}
\seealso{
Other storage: 
\code{\link{tar_format}()},
\code{\link{tar_load}()},
\code{\link{tar_load_everything}()},
\code{\link{tar_load_raw}()},
\code{\link{tar_objects}()},
\code{\link{tar_read}()},
\code{\link{tar_read_raw}()},
\code{\link{tar_repository_cas_local}()}
}
\concept{storage}
