% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_engine_target.R
\name{tar_engine_target}
\alias{tar_engine_target}
\title{\code{knitr} engine for targets}
\usage{
tar_engine_target(
  options,
  package = "targets",
  factory = "tar_target",
  code = "command",
  namer = identity,
  interactive = interactive()
)
}
\arguments{
\item{options}{Named list of \code{knitr} chunk options.}

\item{package}{Character of length 1, name of the package
that supports the target factory.}

\item{factory}{Character of length 1, name of the target factory
corresponding to the engine. Defaults to \code{"tar_target"}
but could be an alternative factory such as \code{"tar_render"}
(from \code{tarchetypes}) or \code{"tar_stan_mcmc"} (from \code{stantargets}).}

\item{code}{Character of length 1, name of a formal argument
to the target factory to insert the code from the chunk.}

\item{namer}{A function that accepts a character
argument of length 1 and returns a character of length 1.
In interactive mode, the engine usually assigns
the chunk's return value to a variable whose name is the chunk name.
This practice does not make sense for all target factories.
For example, \code{stantargets::tar_stan_mcmc(target_name, ...)}
creates many different targets, and the user-supplied R command
generates the upstream Stan data. In this case, the engine
should have \code{namer = function(name) paste0(name, "_data")}.
That way, when the user interactively runs a
\verb{\{tar_stan_mcmc target_name\}} code chunk, the
engine will assign the return value to a variable named
\code{target_name_data}.}

\item{interactive}{Logical of length 1, whether to run in interactive
mode (prototyping) or non-interactive mode (pipeline construction).}
}
\description{
\code{knitr} engine to prototype and construct
targets in a literate programming document.
}
\details{
\code{\link[=tar_engine_target]{tar_engine_target()}} is a \code{knitr} engine to
prototype and construct different kinds of targets.
These engines have two basic behaviors,
depending on whether the R session is interactive.
Interactive sessions are for prototyping,
while non-interactive sessions are for pipeline construction.
In interactive sessions, the engine runs the code in a new
transient environment (in order prevent side effects)
and then assigns the return value
to a variable whose name is the chunk name. This emulates
what happens when a target runs during \code{\link[=tar_make]{tar_make()}}.
In non-interactive sessions, the engine adds the code
to the existing pipeline without running it. More specifically,
it generates a call to the target factory and
writes that call to a file in \verb{_targets_r/targets/}.
In addition, the engine also writes a \verb{_targets.R}
file that leverages the files in \verb{_targets_r/}
to manage the pipeline.
}
\section{Target Markdown}{

Target Markdown is an interface to prototype and construct
\code{targets} pipelines entirely in R Markdown. See
\url{https://books.ropensci.org/targets/markdown.html}
for usage details.
}

\seealso{
\url{https://books.ropensci.org/targets/markdown.html}
}
\concept{Target Markdown}
