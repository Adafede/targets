% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_target_external.R
\name{tar_target_external}
\alias{tar_target_external}
\title{Declare a target from an external interface.}
\usage{
tar_target_external(
  name,
  expr,
  pattern = NULL,
  packages = targets::tar_option("packages", (.packages())),
  library = targets::tar_option("library"),
  deps = NULL,
  string = NULL,
  envir = tar_option("envir", globalenv()),
  format = targets::tar_option("format", "rds"),
  iteration = targets::tar_option("iteration", "vector"),
  error = targets::tar_option("error", "stop"),
  memory = targets::tar_option("memory", "persistent"),
  deployment = targets::tar_option("deployment", "remote"),
  template = targets::tar_option("template", NULL),
  resources = targets::tar_option("resources", list()),
  storage = targets::tar_option("storage", "local"),
  retrieval = targets::tar_option("retrieval", storage),
  cue = targets::tar_option("cue", NULL)
)
}
\arguments{
\item{name}{Character of length 1, name of the target.}

\item{expr}{Similar to the \code{expr} argument of \code{\link[=tar_target]{tar_target()}} except
the object must already be an expression instead of
informally quoted code.
\code{base::expression()} and \code{base::quote()} can produce such objects.}

\item{pattern}{Similar to the \code{pattern} argument of \code{\link[=tar_target]{tar_target()}}
except the object must already be an expression instead of
informally quoted code.
\code{base::expression()} and \code{base::quote()} can produce such objects.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_options()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{deps}{Optional character vector of the adjacent upstream
dependencies of the target, including targets and global objects.
If \code{NULL}, dependencies are resolved automatically as usual.}

\item{string}{Optional string representation of the command.
Internally, the string gets hashed to check if the command changed
since last run, which helps \code{targets} decide whether the
target is up to date. External interfaces can take control of
\code{string} to ignore changes in certain parts of the command.
If \code{NULL}, the strings is just deparsed from \code{expr} (default).}

\item{envir}{Environment containing functions and global objects
used in the R commands to run targets.}

\item{format}{Optional storage format for the target's return value.
With the exception of \code{format = "file"}, each target
gets a file in \verb{_targets/objects}, and each format is a different
way to save and load this file.
Possible formats:
\itemize{
\item \code{"file"}: A dynamic file. To use this format,
the target needs to manually identify or save some data
and return a character vector of paths
to the data. Those paths must point to files or directories,
and they must not contain characters \code{|} or \code{*}.
Then, \code{targets} automatically checks those files and cues the
appropriate build decisions if those files are out of date.
\item \code{"rds"}: Default, uses \code{saveRDS()} and \code{readRDS()}. Should work for
most objects, but slow.
\item \code{"qs"}: Uses \code{qs::qsave()} and \code{qs::qread()}. Should work for
most objects, much faster than \code{"rds"}.
\item \code{"fst"}: Uses \code{fst::write_fst()} and \code{fst::read_fst()}.
Much faster than \code{"rds"}, but the value must be
a data frame.
\item \code{"fst_dt"}: Same as \code{"fst"}, but the value is a \code{data.table}.
\item \code{"fst_tbl"}: Same as \code{"fst"}, but the value is a \code{tibble}.
\item \code{"keras"}: Uses \code{keras::save_model_hdf5()} and
\code{keras::load_model_hdf5()}. The value must be a Keras model.
}}

\item{iteration}{Character of length 1, name of the iteration mode
of the target. Choices:
\itemize{
\item \code{"vector"}: branching happens with \code{vectors::vec_slice()} and
aggregation happens with \code{vctrs::vec_c()}.
\item \code{"list"}, branching happens with \verb{[[]]} and aggregation happens with
\code{list()}.
\item \code{"group"}: \code{dplyr::group_by()}-like functionality to branch over
subsets of a data frame. The target's return value must be a data
frame with a special \code{tar_group} column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the \code{\link[=tar_group]{tar_group()}} function to see how you can
create the special \code{tar_group} column with \code{dplyr::group_by()}.
}}

\item{error}{Character of length 1, what to do if the target
runs into an error. If \code{"stop"}, the whole pipeline stops
and throws an error. If \code{"continue"}, the error is recorded,
but the pipeline keeps going.}

\item{memory}{Character of length 1, memory strategy.
If \code{"persistent"}, the target stays in memory
until the end of the pipeline.
If \code{"transient"}, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[=tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[=tar_make_future]{tar_make_future()}}. If \code{"remote"},
the target builds on a remote parallel worker. If \code{"local"},
the target builds on the host machine / process managing the pipeline.}

\item{template}{Relevant to \code{\link[=tar_make_clustermq]{tar_make_clustermq()}} only.
Named list of values to fill in the \code{clustermq} template file.
Unsupported for now. May be supported in the future if
\code{clustermq} ever supports heterogeneous workers with varying
resource requirements. In the meantime, use the \code{template}
argument of \code{\link[=tar_make_clustermq]{tar_make_clustermq()}}.}

\item{resources}{Relevant to \code{\link[=tar_make_future]{tar_make_future()}} only.
A named list of resources passed to \code{future::future()} when
defining a new worker.}

\item{storage}{Character of length 1, only relevant to
\code{\link[=tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[=tar_make_future]{tar_make_future()}}.
If \code{"local"}, the target's return value is sent back to the
host machine and saved locally. If \code{"remote"}, the remote worker
saves the value.}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[=tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[=tar_make_future]{tar_make_future()}}.
If \code{"local"}, the target's dependencies are loaded on the host machine
and sent to the remote worker before the target builds.
If \code{"remote"}, the remote worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}
}
\value{
A target object. Users should not modify these directly,
just feed them to \code{\link[=tar_pipeline]{tar_pipeline()}} in your \verb{_targets.R} file.
}
\description{
\code{tar_target_external()} is intended
for people who develop infrastructure on top of \code{targets},
and it is not relevant to most end users.
}
\details{
\code{tar_target_external()} is like \code{\link[=tar_target]{tar_target()}},
but it is designed to be called from external interfaces.
Argument \code{name} is a character instead of a symbol, and
arguments \code{expr} and \code{pattern} are expression objects
instead of quoted code. In other words, where \code{\link[=tar_target]{tar_target()}} uses
non-standard evaluation, \code{tar_target_external()} relies totally
on standard evaluation.
In addition, \code{tar_target_external()} supports arguments \code{string}
and \code{deps} to take more control of how commands and their dependencies
are resolved.
The hope is to make it easier for other packages to metaprogram
their own \code{targets} pipelines and develop external
domain specific languages for static branching.
}
\examples{
  # The following are equivalent.
  y <- tar_target(y, sqrt(x), pattern = map(x))
  y <- tar_target_external("y", expression(sqrt(x)), expression(map(x)))
}
